#pragma kernel SimulateBoids

static const float PI = 3.14159265f;

struct Boid {
    uint group;

    float2 position;
    float angle;

    float flockHeading;
    float2 flockCentre;
    float2 seperationHeading;

    int numFlockmates;

    float4 color;
};

RWTexture2D<float4> _BoidMap;
RWStructuredBuffer<Boid> _BoidData;
uint2 _TextureDimensions;

//Simulation settings
uint _BoidCount;
float _BoidSpeed;
float _DetectionDistance;
float _DetectionAngle;
//

float maxSpeed, minSpeed;

float _AvoidanceWeight;

//Move Boid by one step
void MoveBoid(uint3 id){
    float xDiff = (sin(_BoidData[id.x].angle) * _BoidSpeed) % _TextureDimensions.x;
    float yDiff = (cos(_BoidData[id.x].angle) * _BoidSpeed) % _TextureDimensions.y;

    _BoidData[id.x].position += float2(xDiff, yDiff);
    float2 p = _BoidData[id.x].position;

    //Handling wrapping around the texture
    if(p.x < 0) _BoidData[id.x].position.x = _TextureDimensions.x + p.x;
    else if(p.x > (float)_TextureDimensions.x) _BoidData[id.x].position.x = p.x - _TextureDimensions.x;

    
    if(p.y < 0) _BoidData[id.x].position.y = _TextureDimensions.y + p.y;
    else if(p.y > (float)_TextureDimensions.y) _BoidData[id.x].position.y = p.y - _TextureDimensions.y;
}

void SteerTowards(uint3 id, float targetAngle, float weight){
    _BoidData[id.x].angle = lerp(_BoidData[id.x].angle, targetAngle, weight);
}

float4 c;

//Detect neighbours
void Detect(uint3 id){
    for(uint i = 0; i < _BoidCount; i++){
        if(i == id.x) continue;
        //Check its part of the same group
        if (_BoidData[i].group != _BoidData[id.x].group) continue;

        float2 direction = _BoidData[i].position - _BoidData[id.x].position;
        float distToBoid = distance(_BoidData[i].position, _BoidData[id.x].position);

        //Compare square distance
        if(distToBoid * distToBoid <= _DetectionDistance * _DetectionDistance){

            //Flock changes
            _BoidData[id.x].numFlockmates += 1;
            _BoidData[id.x].flockHeading += _BoidData[i].angle;
            _BoidData[id.x].flockCentre += _BoidData[i].position;


            float dirAng = abs(atan(direction.x / direction.y));
            if(direction.y < 0){
                dirAng = (PI) - dirAng;
            }

            float angDiff = (dirAng - _BoidData[id.x].angle) * (-1 * (direction.x < 0));
            
            //Detected in vision
            if(abs(angDiff) < _DetectionAngle / 2){
                c = float4(1, 0, 0, 1);

                //Negative target angle so that they steer in the oposite direction
                SteerTowards(id, _BoidData[id.x].angle + ((_DetectionAngle / 2) - angDiff), _AvoidanceWeight);
            }

        }

    }
}

//Draw the boids position to output texture
void DrawBoid(uint3 id){
    _BoidMap[(uint2)_BoidData[id.x].position.xy] = c;
}

[numthreads(8,1,1)]
void SimulateBoids (uint3 id : SV_DispatchThreadID)
{
    if(!(id.x < _BoidCount)) return;

    //Reset flock values
    _BoidData[id.x].numFlockmates = 0;
    _BoidData[id.x].flockHeading = 0;
    _BoidData[id.x].flockCentre = 0;
    _BoidData[id.x].seperationHeading = 0;

    c = float4(_BoidData[id.x].color.r, _BoidData[id.x].color.g, _BoidData[id.x].color.b, 1);
    MoveBoid(id);
    Detect(id);
    DrawBoid(id);
}
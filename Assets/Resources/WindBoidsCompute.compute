#pragma kernel SimulateBoids

static const float PI = 3.14159265f;

struct Boid {
    uint group;

    float2 position;
    float2 velocity;

    float2 flockHeading;
    float2 flockCentre;
    float2 seperationHeading;

    int numFlockmates;

    float4 color;
};

RWTexture2D<float4> _BoidMap;
RWStructuredBuffer<Boid> _BoidData;
uint2 _TextureDimensions;

//Simulation settings
uint _BoidCount;
float _DetectionDistance;
float _DetectionAngle;

//Movement settings
float _DeltaTime;
float maxSpeed, minSpeed, maxSteerForce;

float _AlignmentWeight;
float _CohesionWeight;
float _AvoidanceWeight;

//Handling moving and wrapping the boids position
void MoveBoid(uint3 id){
    //Move
    _BoidData[id.x].position += _BoidData[id.x].velocity * _DeltaTime;

    //Handling wrapping around the texture
    //x wrapping
    if(_BoidData[id.x].position.x < 0) _BoidData[id.x].position.x += _TextureDimensions.x;
    else if(_BoidData[id.x].position.x > (float)_TextureDimensions.x) _BoidData[id.x].position.x -= _TextureDimensions.x;
    //y wrapping
    if(_BoidData[id.x].position.y < 0) _BoidData[id.x].position.y += _TextureDimensions.y;
    else if(_BoidData[id.x].position.y > (float)_TextureDimensions.y) _BoidData[id.x].position.y -= _TextureDimensions.y;
}

float2 GetWeightedSteer(uint3 id, float2 dir, float weight){
    float2 raw = normalize(dir) * maxSpeed - _BoidData[id.x].velocity;
    float2 clamped;

    //Clamp steer force
    if(length(raw) > maxSteerForce) clamped = normalize(raw) * maxSteerForce;
    else                            clamped = raw;

    return clamped * weight;
}

void SteerBoid(uint3 id){
    float2 acceleration = 0;

    //Flock calculation
    if(_BoidData[id.x].numFlockmates != 0){
        float2 flockCentre = _BoidData[id.x].flockCentre / _BoidData[id.x].numFlockmates;
        float2 offsetToFlockCentre = flockCentre - _BoidData[id.x].position;

        float2 alignmentAccel = GetWeightedSteer(id, _BoidData[id.x].flockHeading, _AlignmentWeight);
        float2 cohesionAccel = GetWeightedSteer(id, offsetToFlockCentre, _CohesionWeight);
        float2 seperationAccel = GetWeightedSteer(id, _BoidData[id.x].seperationHeading, _AvoidanceWeight);

        acceleration += alignmentAccel;
        acceleration += cohesionAccel;
        acceleration += seperationAccel;
    }

    _BoidData[id.x].velocity += acceleration * _DeltaTime;

    //Clamp velocity
    float speed = length(_BoidData[id.x].velocity);
    if(speed < minSpeed) _BoidData[id.x].velocity = normalize(_BoidData[id.x].velocity) * minSpeed;
    if(speed > maxSpeed) _BoidData[id.x].velocity = normalize(_BoidData[id.x].velocity) * maxSpeed;
}

float4 c;

//Detect neighbours
void Detect(uint3 id){
    for(uint i = 0; i < _BoidCount; i++){
        if(i == id.x) continue;
        //Check its part of the same group
        if (_BoidData[i].group != _BoidData[id.x].group) continue;

        float2 direction = _BoidData[i].position - _BoidData[id.x].position;
        float distToBoid = distance(_BoidData[i].position, _BoidData[id.x].position);

        //Compare square distance
        if(distToBoid * distToBoid <= _DetectionDistance * _DetectionDistance){

            //Flock changes
            _BoidData[id.x].numFlockmates += 1;
            _BoidData[id.x].flockHeading += normalize(_BoidData[i].velocity);
            _BoidData[id.x].flockCentre += _BoidData[i].position;

            float2 offsetToBoid = _BoidData[i].position - _BoidData[id.x].position;
            float sqrDist = (offsetToBoid.x * offsetToBoid.x + offsetToBoid.y * offsetToBoid.y);

            //Normalised to remove bottom half of equaltion
            
            //float2 cur = normalize(_BoidData[i].velocity);    //the bane of my existence
            float2 cur = normalize(_BoidData[id.x].velocity);   //fixed :smile:
            float2 target = normalize(offsetToBoid);
            
            //Expensive
            float offsetAngle = acos(dot(cur, target));
            
            //Detected in vision
            if(offsetAngle < _DetectionAngle / 2){
                c = float4(1, 0, 0, 1);
                _BoidData[id.x].seperationHeading -= offsetToBoid / sqrDist;
            }
        }
    }
}

//Draw the boids position to output texture
void DrawBoid(uint3 id){
    _BoidMap[(uint2)_BoidData[id.x].position.xy] = c;
}

[numthreads(8,1,1)]
void SimulateBoids (uint3 id : SV_DispatchThreadID)
{
    if(!(id.x < _BoidCount)) return;

    //Reset flock values
    _BoidData[id.x].numFlockmates = 0;
    _BoidData[id.x].flockHeading = 0;
    _BoidData[id.x].flockCentre = 0;
    _BoidData[id.x].seperationHeading = 0;

    c = float4(_BoidData[id.x].color.r, _BoidData[id.x].color.g, _BoidData[id.x].color.b, 1);
    MoveBoid(id);
    Detect(id);
    //SteerBoid(id);
    DrawBoid(id);
}